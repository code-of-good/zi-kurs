# Пошаговый план работы курсовой: Zero-Knowledge Proof для гамильтонова цикла

## Общая концепция

**Цель:** Prover (доказывающий) хочет доказать Verifier (верификатору), что он знает гамильтонов цикл в графе, **не раскрывая сам цикл**.

**Гамильтонов цикл** - это цикл, который проходит через каждую вершину графа ровно один раз.

---

## Этап 1: Инициализация и подготовка данных

### Шаг 1.1: Загрузка графа
```typescript
// Читаем граф из файла example/1.txt
const graphData = await readFromFile(filePath);
const graph = new Graph(graphData);
```
- Формат файла: первая строка `n m` (количество вершин и рёбер), затем `m` строк с рёбрами `u v`
- Создаётся объект `Graph` с представлением через список смежности и список рёбер

### Шаг 1.2: Загрузка гамильтонова цикла
```typescript
// Читаем цикл из файла example/1-cycle.txt
const hamiltonianCycle = await readCycleFromFile(cycleFilePath);
```
- Формат: последовательность вершин, например `[0, 1, 2, 3, 0]`
- Проверяется валидность цикла через `isValidHamiltonianCycle()`

### Шаг 1.3: Создание участников протокола
```typescript
const prover = new Prover(graph, hamiltonianCycle);  // Знает цикл
const verifier = new Verifier(graph);                // Знает только граф
```
- **Prover** хранит оригинальный граф и гамильтонов цикл
- **Verifier** знает только граф, но не знает цикл

---

## Этап 2: Параметры протокола

### Шаг 2.1: Выбор количества раундов
```typescript
const k = 5;  // Количество раундов протокола
```
- Чем больше `k`, тем ниже вероятность обмана: `1/2^k`
- При `k=5`: вероятность обмана = `1/32 ≈ 3.125%`
- При `k=20`: вероятность обмана = `1/1048576 ≈ 0.000095%`

### Шаг 2.2: Генерация challenges
```typescript
const challenges: (0 | 1)[] = [];
for (let i = 0; i < k; i++) {
  challenges.push(verifier.generateChallenge());
}
```
- Verifier генерирует `k` случайных challenges (0 или 1)
- Каждый challenge выбирается криптографически случайно через `crypto.randomBytes()`
- Challenges определяют, что должен показать Prover в каждом раунде

---

## Этап 3: Выполнение протокола (k раундов)

Протокол повторяется `k` раз. Каждый раунд независим и использует **новую случайную перестановку**.

### Структура одного раунда:

#### **Фаза 1: Коммит (Commit)**

**Prover выполняет:**

1. **Генерация случайной перестановки**
   ```typescript
   const permutation = generateRandomPermutation(n);
   // Например: [2, 0, 1, 3] означает:
   //   вершина 0 → вершина 2
   //   вершина 1 → вершина 0
   //   вершина 2 → вершина 1
   //   вершина 3 → вершина 3
   ```
   - Создаётся случайная биекция вершин `[0..n-1] → [0..n-1]`
   - Используется криптографически стойкий ГСЧ (Fisher-Yates shuffle)

2. **Применение перестановки к графу**
   ```typescript
   const permutedGraph = applyPermutationToGraph(graph, permutation);
   // G' = π(G)
   ```
   - Для каждого ребра `(u, v)` в оригинальном графе создаётся ребро `(π(u), π(v))` в `G'`
   - Граф `G'` изоморфен `G`, но вершины переименованы

3. **Создание криптографического коммита**
   ```typescript
   const commitment = commitToGraph(permutedGraph, permutation);
   // commitment = { hash: SHA256(serialized(G') + salt), salt: random }
   ```
   - Граф `G'` сериализуется в строку (отсортированные рёбра)
   - Генерируется случайный `salt` (32 байта)
   - Вычисляется `hash = SHA256(serialized(G') + salt)`
   - **Важно:** Verifier получает только `{hash, salt}`, но не может восстановить `G'` из hash

**Результат:** Prover отправляет Verifier только `commitment = {hash, salt}`

---

#### **Фаза 2: Challenge (Вызов)**

**Verifier выполняет:**

```typescript
const challenge = challenges[roundIndex];  // 0 или 1
```

- Verifier выбирает случайный challenge из предварительно сгенерированного массива
- **Challenge = 0:** "Покажи перестановку и докажи, что G' = π(G)"
- **Challenge = 1:** "Покажи гамильтонов цикл в G' (без раскрытия перестановки)"

---

#### **Фаза 3: Response (Ответ)**

**Prover отвечает в зависимости от challenge:**

##### **Если Challenge = 0: "Покажи перестановку"**

```typescript
response = {
  type: 0,
  permutation: [2, 0, 1, 3],           // Раскрывает перестановку π
  permutedGraphEdges: [[0,1], [1,2], [2,3], [3,0]]  // Все рёбра G'
}
```

**Что раскрывается:**
- Перестановка `π` полностью
- Все рёбра переставленного графа `G'`

**Что НЕ раскрывается:**
- Исходный гамильтонов цикл (Verifier видит только структуру графа)

##### **Если Challenge = 1: "Покажи цикл"**

```typescript
// Сначала применяем перестановку к циклу
const permutedCycle = applyPermutationToCycle(hamiltonianCycle, permutation);
// Например: [0,1,2,3] → [2,0,1,3] (если π = [2,0,1,3])

// Затем формируем рёбра цикла в G'
const cycleEdges = [[2,0], [0,1], [1,3], [3,2]];

response = {
  type: 1,
  permutedGraphEdges: [[0,1], [1,2], [2,3], [3,0]],  // Все рёбра G'
  cycleEdges: [[2,0], [0,1], [1,3], [3,2]]          // Рёбра цикла в G'
}
```

**Что раскрывается:**
- Все рёбра графа `G'`
- Рёбра гамильтонова цикла в `G'`

**Что НЕ раскрывается:**
- Перестановка `π` (Verifier не знает, как `G'` соотносится с `G`)

---

#### **Фаза 4: Verification (Проверка)**

**Verifier проверяет ответ:**

##### **Проверка для Challenge = 0:**

1. **Валидность перестановки**
   ```typescript
   isValidPermutation(permutation, n)
   ```
   - Проверяет, что перестановка - биекция `[0..n-1] → [0..n-1]`
   - Нет дубликатов, все значения в диапазоне

2. **Проверка коммита**
   ```typescript
   openCommitment(commitment, serialized(permutedGraph))
   ```
   - Восстанавливает `G'` из `permutedGraphEdges`
   - Сериализует `G'` так же, как при создании коммита
   - Вычисляет `SHA256(serialized(G') + salt)` и сравнивает с `commitment.hash`
   - **Если не совпадает → доказательство отвергнуто**

3. **Проверка изоморфизма**
   ```typescript
   originalGraph.isIsomorphicTo(permutedGraph, permutation)
   ```
   - Проверяет, что `G' = π(G)`
   - Для каждого ребра `(u, v)` в `G` проверяет наличие ребра `(π(u), π(v))` в `G'`
   - Для каждого ребра `(u', v')` в `G'` проверяет наличие ребра `(π⁻¹(u'), π⁻¹(v'))` в `G`

**Результат:** Если все проверки пройдены → раунд принят ✓

##### **Проверка для Challenge = 1:**

1. **Проверка коммита**
   ```typescript
   openCommitment(commitment, serialized(permutedGraph))
   ```
   - Аналогично Challenge 0: проверяет, что `G'` соответствует коммиту

2. **Валидность рёбер цикла**
   ```typescript
   // Проверки:
   - cycleEdges.length === n (правильное количество рёбер)
   - Все вершины в диапазоне [0..n-1]
   - Нет self-loops (u !== v)
   ```

3. **Существование рёбер в графе**
   ```typescript
   for (const [u, v] of cycleEdges) {
     if (!permutedGraph.hasEdge(u, v)) {
       return false;  // Ребро не существует в G'
     }
   }
   ```

4. **Проверка гамильтонова цикла**
   ```typescript
   const cycle = edgesToCycle(cycleEdges, n);
   isValidHamiltonianCycle(cycle, permutedGraph);
   ```
   - Восстанавливает последовательность вершин из рёбер
   - Проверяет, что каждая вершина встречается ровно один раз
   - Проверяет, что рёбра образуют цикл (последняя вершина соединена с первой)

**Результат:** Если все проверки пройдены → раунд принят ✓

---

## Этап 4: Финальная проверка

### Шаг 4.1: Проверка всех раундов
```typescript
const result = verifier.verifyProof(proof, graph);
```

**Verifier проверяет:**
- Количество раундов соответствует `k`
- Каждый раунд прошёл проверку (`verifyRound()`)
- Если хотя бы один раунд не прошёл → доказательство **отвергнуто**

### Шаг 4.2: Результат
```typescript
if (result.valid) {
  console.log("Доказательство ПРИНЯТО");
} else {
  console.log(`Доказательство ОТВЕРГНУТО на раунде ${result.failedRound}`);
}
```

---

## Почему это работает? (Безопасность протокола)

### 1. **Zero-Knowledge (Нулевое раскрытие)**

Verifier **не узнаёт** исходный цикл, потому что:
- **Challenge 0:** Видит только перестановку и структуру графа, но не цикл
- **Challenge 1:** Видит цикл в переставленном графе, но не знает перестановку (не может связать с исходным графом)
- Каждый раунд использует **новую** случайную перестановку → нельзя связать информацию между раундами

### 2. **Soundness (Звучность)**

Prover **не может обмануть**, если не знает цикл:
- Если угадает `challenge = 0`: может показать любую перестановку и граф
- Если угадает `challenge = 1`: должен показать цикл в `G'`, но его нет → провал
- Вероятность угадать все `k` раундов: `1/2^k` (экспоненциально мала)

**Пример обмана:**
```
Раунд 1: Prover коммитит G' без цикла
         Challenge = 0 → Prover показывает перестановку ✓ (проходит)
Раунд 2: Prover коммитит G'' с циклом
         Challenge = 1 → Prover показывает цикл ✓ (проходит)
Раунд 3: Challenge = 1 → Prover должен показать цикл в G', но его нет → ❌ ПРОВАЛ
```

### 3. **Completeness (Полнота)**

Если Prover **знает** цикл, он всегда может ответить правильно:
- **Challenge 0:** Показывает перестановку и граф `G' = π(G)` ✓
- **Challenge 1:** Показывает переставленный цикл `π(cycle)` в `G'` ✓

### 4. **Роль коммита**

**Без коммита** (небезопасно):
```
1. Verifier: challenge = 0
2. Prover: показывает π, G'
3. Verifier: откатывает назад, challenge = 1
4. Prover: показывает другой граф G'' с циклом (обман!)
```

**С коммитом** (безопасно):
```
1. Prover: коммитит G' (фиксирует граф)
2. Verifier: challenge = 0 или 1 (случайно)
3. Prover: должна показать тот же G', что закоммитила
4. Verifier: проверяет коммит → подмена невозможна
```

Коммит **связывает** Prover с конкретным графом `G'` до выбора challenge.

---

## Пример выполнения (k=3 раунда)

### Раунд 1:
```
Prover:  Генерирует π₁ = [2,0,1,3], создаёт G'₁, коммитит → {hash₁, salt₁}
Verifier: Получает коммит, генерирует challenge₁ = 0
Prover:  Отвечает: π₁ = [2,0,1,3], все рёбра G'₁
Verifier: Проверяет: ✓ перестановка валидна, ✓ коммит корректен, ✓ G'₁ = π₁(G)
         Результат: ✓ ПРИНЯТО
```

### Раунд 2:
```
Prover:  Генерирует π₂ = [1,3,0,2] (НОВАЯ!), создаёт G'₂, коммитит → {hash₂, salt₂}
Verifier: Получает коммит, генерирует challenge₂ = 1
Prover:  Отвечает: все рёбра G'₂, рёбра цикла в G'₂ (π₂ НЕ раскрыта)
Verifier: Проверяет: ✓ коммит корректен, ✓ цикл валиден в G'₂
         Результат: ✓ ПРИНЯТО
```

### Раунд 3:
```
Prover:  Генерирует π₃ = [0,2,3,1] (ЕЩЁ ОДНА!), создаёт G'₃, коммитит → {hash₃, salt₃}
Verifier: Получает коммит, генерирует challenge₃ = 0
Prover:  Отвечает: π₃ = [0,2,3,1], все рёбра G'₃
Verifier: Проверяет: ✓ перестановка валидна, ✓ коммит корректен, ✓ G'₃ = π₃(G)
         Результат: ✓ ПРИНЯТО
```

**Итог:** Все 3 раунда прошли → **Доказательство ПРИНЯТО** ✓

Вероятность обмана без знания цикла: `1/2³ = 1/8 = 12.5%`

---

## Ключевые моменты реализации

### Криптографические примитивы:
- **SHA-256** для хеширования коммитов
- **crypto.randomBytes()** для генерации случайных перестановок и challenges
- **Salt** для предотвращения атак перебора

### Структуры данных:
- **Graph:** список смежности + список рёбер
- **Permutation:** массив `[0..n-1]` с перестановкой
- **Commitment:** `{hash: string, salt: string}`
- **ProofRound:** `{commitment, response}`
- **ZKPProof:** `{rounds: ProofRound[], k: number}`

### Важные детали:
- Каждый раунд использует **независимую** случайную перестановку
- Сериализация графа всегда одинаковая (отсортированные рёбра)
- Проверка изоморфизма двусторонняя (G → G' и G' → G)
- Валидация цикла проверяет все условия (количество вершин, связность, цикличность)

---

## Итоговая схема протокола

```
┌─────────────────────────────────────────────────────────────┐
│                    ИНИЦИАЛИЗАЦИЯ                            │
│  - Загрузка графа G и гамильтонова цикла                    │
│  - Создание Prover и Verifier                                │
│  - Выбор k (количество раундов)                             │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              ГЕНЕРАЦИЯ CHALLENGES (k штук)                   │
│  Verifier генерирует случайные challenges: [0,1,0,1,1,...] │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
        ┌───────────────────────────────────┐
        │   РАУНД 1, РАУНД 2, ..., РАУНД k  │
        └───────────────────────────────────┘
                            │
        ┌───────────────────┴───────────────────┐
        │                                       │
        ▼                                       ▼
┌──────────────────┐                  ┌──────────────────┐
│  COMMIT          │                  │  COMMIT          │
│  Prover:         │                  │  Prover:         │
│  - π₁, G'₁      │                  │  - π₂, G'₂      │
│  - commitment₁   │                  │  - commitment₂   │
└──────────────────┘                  └──────────────────┘
        │                                       │
        ▼                                       ▼
┌──────────────────┐                  ┌──────────────────┐
│  CHALLENGE       │                  │  CHALLENGE       │
│  Verifier: 0     │                  │  Verifier: 1     │
└──────────────────┘                  └──────────────────┘
        │                                       │
        ▼                                       ▼
┌──────────────────┐                  ┌──────────────────┐
│  RESPONSE        │                  │  RESPONSE        │
│  Prover:         │                  │  Prover:         │
│  - π₁, G'₁      │                  │  - G'₂, cycle   │
│  (цикл скрыт)   │                  │  (π₂ скрыта)    │
└──────────────────┘                  └──────────────────┘
        │                                       │
        ▼                                       ▼
┌──────────────────┐                  ┌──────────────────┐
│  VERIFICATION    │                  │  VERIFICATION    │
│  Verifier:       │                  │  Verifier:       │
│  ✓ коммит        │                  │  ✓ коммит        │
│  ✓ изоморфизм    │                  │  ✓ цикл валиден  │
└──────────────────┘                  └──────────────────┘
        │                                       │
        └───────────────────┬───────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│              ФИНАЛЬНАЯ ПРОВЕРКА                             │
│  Если все k раундов прошли → ДОКАЗАТЕЛЬСТВО ПРИНЯТО         │
│  Если хотя бы один провалился → ДОКАЗАТЕЛЬСТВО ОТВЕРГНУТО   │
└─────────────────────────────────────────────────────────────┘
```

---

## Заключение

Протокол Zero-Knowledge Proof для гамильтонова цикла позволяет:
- ✅ **Prover** доказать знание цикла без его раскрытия
- ✅ **Verifier** убедиться в существовании цикла
- ✅ Вероятность обмана экспоненциально мала: `1/2^k`
- ✅ Zero-Knowledge свойство: Verifier не узнаёт исходный цикл

**Ключевой принцип:** Каждый раунд даёт Verifier'у только частичную информацию (либо перестановку, либо цикл), но никогда не обе одновременно, что гарантирует нулевое раскрытие знания.

