# Как работает программа: Zero-Knowledge Proof для гамильтонова цикла

## Обзор

Программа реализует интерактивный протокол ZKP, который позволяет Prover доказать Verifier'у, что он знает гамильтонов цикл в графе, не раскрывая сам цикл.

## Пошаговое описание работы

### Шаг 1: Инициализация

1. **Загрузка данных**

   - Читается граф из файла (`example/1.txt`)
   - Читается гамильтонов цикл из файла (`example/1-cycle.txt`)
   - Проверяется валидность цикла

2. **Создание участников**
   - `Prover` - знает граф и гамильтонов цикл
   - `Verifier` - знает только граф, не знает цикл

### Шаг 2: Демонстрация протокола (опционально)

Программа демонстрирует работу отдельных компонентов:

- `generateCommitment()` - создание коммита к переставленному графу
- `respondToChallenge(0)` - ответ на Challenge 0 (раскрытие перестановки)
- `respondToChallenge(1)` - ответ на Challenge 1 (раскрытие цикла)

### Шаг 3: Полный протокол ZKP

#### 3.1. Генерация challenges

Verifier генерирует `k` случайных challenges (по умолчанию `k=5`):

- Каждый challenge = 0 или 1 (случайно)
- Вероятность обмана без знания цикла: `1/2^k`

#### 3.2. Генерация доказательства (Prover)

Для каждого из `k` раундов:

1. **Генерация коммита**

   - Создается случайная перестановка π вершин
   - Граф переставляется: G' = π(G)
   - Создается криптографический коммит к G' (SHA-256 hash + salt)

2. **Получение challenge**

   - Берется challenge для текущего раунда из массива

3. **Формирование ответа**

   - **Challenge 0**: Раскрывается перестановка π и все рёбра G'
   - **Challenge 1**: Раскрываются только рёбра переставленного цикла в G' (перестановка НЕ раскрывается)

4. **Сохранение раунда**
   - Коммит и ответ сохраняются в структуру `ProofRound`

#### 3.3. Проверка доказательства (Verifier)

Для каждого раунда проверяется:

**Challenge 0:**

- Перестановка валидна (биекция [0..n-1])
- Коммит соответствует графу G'
- G' = π(G) (проверка изоморфизма)

**Challenge 1:**

- Показано правильное количество рёбер (n рёбер)
- Все рёбра валидны (вершины в диапазоне [0..n-1])
- Рёбра образуют валидный гамильтонов цикл

### Шаг 4: Результат

- Если все `k` раундов прошли проверку → **Доказательство ПРИНЯТО**
- Если хотя бы один раунд не прошел → **Доказательство ОТВЕРГНУТО** (с указанием номера раунда)

## Безопасность

- **Zero-Knowledge**: Verifier не узнает исходный цикл, только убеждается в его существовании
- **Soundness**: Вероятность обмана без знания цикла = `1/2^k`
- **Completeness**: Если Prover знает цикл, доказательство всегда принимается

## Ключевые компоненты

- **`Prover`**: Генерирует доказательство, отвечает на challenges
- **`Verifier`**: Проверяет доказательство, генерирует challenges
- **`Graph`**: Представление графа с проверкой изоморфизма
- **`commitment`**: Криптографические коммиты (SHA-256)
- **`permutation`**: Работа с перестановками вершин
